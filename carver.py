import zipfile
import io
import os

def carve_compressed_data(binary_path: str, start_offset: int, length: int) -> bytes:
    with open(binary_path, "rb") as f:
        f.seek(start_offset)

        # Check if the requested length goes beyond the file size
        remaining_bytes = len(f.read())
        if remaining_bytes < length:
            print(f"Requested length of {length} bytes, but only {remaining_bytes} bytes available from offset.")
            exit(-1)

        # Return to the start_offset position
        f.seek(start_offset)

        # Read the desired amount of data
        carved_data = f.read(length)

    return carved_data

def extract_embedded_zip(binary_path: str) -> bytes:
    START_SIG = b'\x50\x4B\x03\x04'
    END_SIG = b'\x50\x4B\x05\x06'

    with open(binary_path, 'rb') as f:
        data = f.read()

    # Find start of the ZIP
    start_index = data.find(START_SIG)
    if start_index == -1:
        print("ZIP start signature not found!")
        exit(-1)

    # Reverse search for the end of the ZIP
    end_index = data.rfind(END_SIG)
    if end_index == -1:
        print("ZIP end signature not found!")
        exit(-1)

    # Footer is 22 bytes minimum, but can be more due to comments.
    zip_buffer = data[start_index:end_index+22]

    return zip_buffer

def find_zip_offset(file_path: str) -> int:
    START_SIG = b'\x50\x4B\x03\x04'  # ZIP start signature

    with open(file_path, 'rb') as f:
        data = f.read()

    # Find start of the ZIP
    start_index = data.find(START_SIG)
    if start_index == -1:
        print("ZIP start signature not found!")
        return -1

    return start_index

def unzip_and_save(carved_zip: bytes, extraction_path: str):
    """
    Decompresses the given ZIP data and saves the extracted content to the specified directory.
    
    :param carved_zip: The compressed ZIP data as a byte object.
    :param extraction_path: The path to the directory where the extracted files will be saved.
    """
    try:
        with zipfile.ZipFile(io.BytesIO(carved_zip), 'r') as zip_ref:
            zip_ref.extractall(extraction_path)
            print(f"Extracted content to {extraction_path}")
    except zipfile.BadZipFile:
        print("Error: The provided data is not a valid ZIP file.")
    except Exception as e:
        print(f"An error occurred: {e}")

def main():
    binary_path = './backup.dll'  # Replace with your binary file path
    extraction_path = './extracted_files'
    
    # Find the offset of the ZIP archive
    zip_offset = find_zip_offset(binary_path)
    if zip_offset == -1:
        print("ZIP archive not found in the specified file.")
        return

    # Carve data from binary file starting at the ZIP offset
    length = 1024  # Set an appropriate length for the ZIP data
    carved_data = carve_compressed_data(binary_path, zip_offset, length)
    print(f"Carved data size: {len(carved_data)} bytes")

    # Extract ZIP from the carved data
    zip_data = extract_embedded_zip(binary_path)
    print(f"Extracted ZIP size: {len(zip_data)} bytes")

    # Ensure the extraction directory exists
    if not os.path.exists(extraction_path):
        os.makedirs(extraction_path)

    # Decompress and save the files
    unzip_and_save(zip_data, extraction_path)

if __name__ == "__main__":
    main()
