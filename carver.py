def carve_compressed_data(binary_path: str, start_offset: int, length: int) -> bytes:
    with open(binary_path, "rb") as f:
        f.seek(start_offset)

        # Check if the requested length goes beyond the file size
        remaining_bytes = len(f.read())
        if remaining_bytes < length:
            print(f"Requested length of {length} bytes, but only {remaining_bytes} bytes available from offset.")
            exit(-1)

        # Return to the start_offset position
        f.seek(start_offset)

        # Read the desired amount of data
        carved_data = f.read(length)

    return carved_data


def extract_embedded_zip(binary_path: str) -> bytes:
    START_SIG = b'\x50\x4B\x03\x04'
    END_SIG = b'\x50\x4B\x05\x06'

    with open(binary_path, 'rb') as f:
        data = f.read()

    # Find start of the ZIP
    start_index = data.find(START_SIG)
    if start_index == -1:
        print("ZIP start signature not found!")
        exit(-1)

    # Reverse search for the end of the ZIP
    end_index = data.rfind(END_SIG)
    if end_index == -1:
        print("ZIP end signature not found!")
        exit(-1)

    # Footer is 22 bytes minimum, but can be more due to comments.
    zip_buffer = data[start_index:end_index+22]

    return zip_buffer


def main():
    binary_path = './backup.dll'  # Replace with your binary file path
    start_offset = 0x1000  # Replace with the start offset you want to carve from
    length = 1024  # Replace with the length you want to carve

    # Carve data from binary file
    carved_data = carve_compressed_data(binary_path, start_offset, length)
    print(f"Carved data size: {len(carved_data)} bytes")

    # Extract ZIP from the carved data
    zip_data = extract_embedded_zip(binary_path)
    print(f"Extracted ZIP size: {len(zip_data)} bytes")

    # Optionally, you could write the ZIP data to a file
    with open('extracted.zip', 'wb') as zip_file:
        zip_file.write(zip_data)
    print("Extracted ZIP written to 'extracted.zip'")

if __name__ == "__main__":
    main()
